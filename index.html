<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/svg+xml" href="/vite.svg" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>sse-stream-parser</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f5f5f5;
    }

    .container {
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }

    .demo-section {
      margin-bottom: 30px;
      padding: 15px;
      border: 1px solid #ddd;
      border-radius: 5px;
    }

    .demo-section h3 {
      margin-top: 0;
      color: #333;
    }

    button {
      background: #007cba;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      margin-right: 10px;
      margin-bottom: 10px;
    }

    button:hover {
      background: #005a87;
    }

    button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }

    .output {
      background: #f8f9fa;
      border: 1px solid #e9ecef;
      border-radius: 4px;
      padding: 10px;
      margin-top: 10px;
      font-family: monospace;
      white-space: pre-wrap;
      max-height: 200px;
      overflow-y: auto;
    }

    .status {
      padding: 5px 10px;
      border-radius: 3px;
      font-size: 12px;
      font-weight: bold;
    }

    .status.running {
      background: #d4edda;
      color: #155724;
    }

    .status.stopped {
      background: #f8d7da;
      color: #721c24;
    }

    a {
      color: #007cba;
      text-decoration: none;
    }

    a:hover {
      text-decoration: underline;
    }

    p {
      margin: 10px 0;
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>SSE Stream Parser åœ¨çº¿æ¼”ç¤º</h1>
    <p>è¿™æ˜¯ä¸€ä¸ªç”¨äºå¤„ç† Server-Sent Events (SSE) æµæ•°æ®çš„ TypeScript åº“çš„åœ¨çº¿æ¼”ç¤ºã€‚</p>
    <p>
      <a href="https://github.com/BinZizai/sse-stream-parser" target="_blank">ğŸ“¦ GitHub ä»“åº“</a> | 
      <a href="https://www.npmjs.com/package/sse-stream-parser" target="_blank">ğŸ“¦ NPM åŒ…</a>
    </p>

    <div class="demo-section">
      <h3>ç¤ºä¾‹ 1: å¼‚æ­¥è¿­ä»£å™¨ (for await...of)</h3>
      <button id="demo1-start">å¼€å§‹æµå¼å¤„ç†</button>
      <button id="demo1-stop" disabled>åœæ­¢</button>
      <div>çŠ¶æ€: <span id="demo1-status" class="status">å¾…å¼€å§‹</span></div>
      <div class="output" id="demo1-output">ç­‰å¾…å¼€å§‹...</div>
    </div>

    <div class="demo-section">
      <h3>ç¤ºä¾‹ 2: è®¢é˜…æ¨¡å¼ (subscribe)</h3>
      <button id="demo2-start">å¼€å§‹è®¢é˜…</button>
      <button id="demo2-stop" disabled>å–æ¶ˆè®¢é˜…</button>
      <div>çŠ¶æ€: <span id="demo2-status" class="status">å¾…å¼€å§‹</span></div>
      <div class="output" id="demo2-output">ç­‰å¾…å¼€å§‹...</div>
    </div>

    <div class="demo-section">
      <h3>ç¤ºä¾‹ 3: è‡ªå®šä¹‰è½¬æ¢æµ</h3>
      <button id="demo3-start">å¼€å§‹è‡ªå®šä¹‰å¤„ç†</button>
      <button id="demo3-stop" disabled>åœæ­¢</button>
      <div>çŠ¶æ€: <span id="demo3-status" class="status">å¾…å¼€å§‹</span></div>
      <div class="output" id="demo3-output">ç­‰å¾…å¼€å§‹...</div>
    </div>
  </div>

  <script type="module">
      import SseStreamParser from './src/index.ts';


    // Mock æ•°æ®ç”Ÿæˆå‡½æ•°
    const streamChunks = ['ã€Šé™å¤œæ€ã€‹', 'å”Â·æç™½', 'åºŠå‰æ˜æœˆå…‰', 'ç–‘æ˜¯åœ°ä¸Šéœœ', 'ä¸¾å¤´æœ›æ˜æœˆ', 'ä½å¤´æ€æ•…ä¹¡'];
    function mockGetReadableStream() {
      const sseChunks = [];

      for (let i = 0; i < streamChunks.length; i++) {
        const sseEventPart = `event: message\ndata: {"id":"${i}","content":"${streamChunks[i]}"}\n\n`;
        sseChunks.push(sseEventPart);
      }

      return new ReadableStream({
        async start(controller) {
          for (const chunk of sseChunks) {
            await new Promise((resolve) => setTimeout(resolve, 300)); // 500ms å»¶è¿Ÿï¼Œä¾¿äºè§‚å¯Ÿ
            controller.enqueue(new TextEncoder().encode(chunk));
          }
          controller.close();
        },
      });
    }

    // å·¥å…·å‡½æ•°
    function updateOutput(elementId, content, append = true) {
      const element = document.getElementById(elementId);
      if (append) {
        element.textContent += content + '\n';
      } else {
        element.textContent = content;
      }
      element.scrollTop = element.scrollHeight;
    }

    function updateStatus(elementId, status, text) {
      const element = document.getElementById(elementId);
      element.className = `status ${status}`;
      element.textContent = text;
    }

    function setButtonState(startId, stopId, isRunning) {
      document.getElementById(startId).disabled = isRunning;
      document.getElementById(stopId).disabled = !isRunning;
    }

    // ç¤ºä¾‹ 1: å¼‚æ­¥è¿­ä»£å™¨
    let demo1Controller = null;
    document.getElementById('demo1-start').addEventListener('click', async () => {
      setButtonState('demo1-start', 'demo1-stop', true);
      updateStatus('demo1-status', 'running', 'è¿è¡Œä¸­...');
      updateOutput('demo1-output', 'å¼€å§‹å¤„ç† SSE æµ...', false);

      try {
        const readableStream = mockGetReadableStream();
        const stream = SseStreamParser({ readableStream });

        // ä½¿ç”¨ AbortController æ¥æ§åˆ¶åœæ­¢
        demo1Controller = new AbortController();

        updateOutput('demo1-output', 'åˆ›å»º SSE æµæˆåŠŸï¼Œå¼€å§‹è¿­ä»£...');

        for await (const event of stream) {
          if (demo1Controller.signal.aborted) break;
          if (event.data) {
            event.data = JSON.parse(event.data);
          }
          updateOutput('demo1-output', `æ”¶åˆ°äº‹ä»¶: ${JSON.stringify(event)}`);
        }

        if (!demo1Controller.signal.aborted) {
          updateStatus('demo1-status', 'completed', 'å·²å®Œæˆ');
          updateOutput('demo1-output', 'æµå¤„ç†å®Œæˆï¼');
        }
      } catch (error) {
        updateStatus('demo1-status', 'stopped', 'å‡ºé”™');
        updateOutput('demo1-output', `é”™è¯¯: ${error.message}`);
      } finally {
        setButtonState('demo1-start', 'demo1-stop', false);
      }
    });

    document.getElementById('demo1-stop').addEventListener('click', () => {
      if (demo1Controller) {
        demo1Controller.abort();
        updateStatus('demo1-status', 'stopped', 'å·²åœæ­¢');
        updateOutput('demo1-output', 'ç”¨æˆ·æ‰‹åŠ¨åœæ­¢');
        setButtonState('demo1-start', 'demo1-stop', false);
      }
    });

    // ç¤ºä¾‹ 2: è®¢é˜…æ¨¡å¼
    let demo2Unsubscribe = null;
    document.getElementById('demo2-start').addEventListener('click', async () => {
      setButtonState('demo2-start', 'demo2-stop', true);
      updateStatus('demo2-status', 'running', 'è®¢é˜…ä¸­...');
      updateOutput('demo2-output', 'å¼€å§‹è®¢é˜… SSE æµ...', false);

      try {
        const readableStream = mockGetReadableStream();
        const stream = SseStreamParser({ readableStream });

        updateOutput('demo2-output', 'åˆ›å»º SSE æµæˆåŠŸï¼Œå¼€å§‹è®¢é˜…...');

        demo2Unsubscribe = stream.subscribe(
          (event) => {
            if (event.data) {
              event.data = JSON.parse(event.data);
            }
            updateOutput('demo2-output', `è®¢é˜…æ”¶åˆ°: ${JSON.stringify(event)}`);
          },
          () => {
            updateStatus('demo2-status', 'completed', 'å·²å®Œæˆ');
            updateOutput('demo2-output', 'è®¢é˜…å®Œæˆï¼');
            setButtonState('demo2-start', 'demo2-stop', false);
            demo2Unsubscribe = null;
          }
        );
      } catch (error) {
        updateStatus('demo2-status', 'stopped', 'å‡ºé”™');
        updateOutput('demo2-output', `é”™è¯¯: ${error.message}`);
        setButtonState('demo2-start', 'demo2-stop', false);
      }
    });

    document.getElementById('demo2-stop').addEventListener('click', () => {
      if (demo2Unsubscribe) {
        demo2Unsubscribe();
        demo2Unsubscribe = null;
        updateStatus('demo2-status', 'stopped', 'å·²å–æ¶ˆ');
        updateOutput('demo2-output', 'è®¢é˜…å·²å–æ¶ˆ');
        setButtonState('demo2-start', 'demo2-stop', false);
      }
    });

    // ç¤ºä¾‹ 3: è‡ªå®šä¹‰è½¬æ¢æµ
    let demo3Controller = null;
    document.getElementById('demo3-start').addEventListener('click', async () => {
      setButtonState('demo3-start', 'demo3-stop', true);
      updateStatus('demo3-status', 'running', 'è¿è¡Œä¸­...');
      updateOutput('demo3-output', 'å¼€å§‹è‡ªå®šä¹‰è½¬æ¢å¤„ç†...', false);

      try {
        const readableStream = mockGetReadableStream();

        // è‡ªå®šä¹‰è½¬æ¢æµï¼šæ·»åŠ æ—¶é—´æˆ³å’Œå¤„ç†æ ‡è®°
        const customTransform = new TransformStream({
          transform(chunk, controller) {
            try {
              // è§£æ SSE æ ¼å¼


              const lines = chunk.split('\n').filter(line => line.trim());
              const event = {};

              for (const line of lines) {
                if (line.includes(':')) {
                  const [key, ...valueParts] = line.split(':');
                  const value = valueParts.join(':').trim();
                  if (key.trim() && value) {
                    event[key.trim()] = value;
                  }
                }
              }

              if (event.data) {
                try {
                  const parsedData = JSON.parse(event.data);
                  // è‡ªå®šä¹‰è½¬æ¢ï¼šæ·»åŠ æ—¶é—´æˆ³å’Œå¤„ç†æ ‡è®°
                  const transformedData = { ...parsedData, event: event.event || 'unknown' };
                  controller.enqueue(transformedData);
                } catch (e) {
                  // å¦‚æœä¸æ˜¯ JSONï¼Œç›´æ¥ä¼ é€’
                  controller.enqueue({ rawData: event.data, event: event.event || 'unknown' });
                }
              }
            } catch (error) {
              console.error('è½¬æ¢é”™è¯¯:', error);
            }
          }
        });

        const stream = SseStreamParser({
          readableStream,
          transformStream: customTransform
        });

        demo3Controller = new AbortController();
        updateOutput('demo3-output', 'åˆ›å»ºè‡ªå®šä¹‰è½¬æ¢æµæˆåŠŸï¼Œå¼€å§‹å¤„ç†...');

        for await (const transformedData of stream) {
          if (demo3Controller.signal.aborted) break;

          updateOutput('demo3-output', `è½¬æ¢åæ•°æ®: ${JSON.stringify(transformedData)}`);
        }

        if (!demo3Controller.signal.aborted) {
          updateStatus('demo3-status', 'completed', 'å·²å®Œæˆ');
          updateOutput('demo3-output', 'è‡ªå®šä¹‰è½¬æ¢å¤„ç†å®Œæˆï¼');
        }
      } catch (error) {
        updateStatus('demo3-status', 'stopped', 'å‡ºé”™');
        updateOutput('demo3-output', `é”™è¯¯: ${error.message}`);
      } finally {
        setButtonState('demo3-start', 'demo3-stop', false);
      }
    });

    document.getElementById('demo3-stop').addEventListener('click', () => {
      if (demo3Controller) {
        demo3Controller.abort();
        updateStatus('demo3-status', 'stopped', 'å·²åœæ­¢');
        updateOutput('demo3-output', 'ç”¨æˆ·æ‰‹åŠ¨åœæ­¢');
        setButtonState('demo3-start', 'demo3-stop', false);
      }
    });
  </script>
</body>

</html>